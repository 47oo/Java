### 一切都是对象
+ 用引用操纵对象
  > 在Java的理解中是按值传递

  >这个地方需要这样理解:
  + 基本类型按值传递:
      传递的是其值的一个副本
  + 对象按值传递:传递的是对象引用(因为最开始对象变量获得的就是对象的引用或者说是对象的地址,所以说是按值传递)

***
+ 你必须创建所有的对象
  > 一旦创建了一个引用,就希望它能够与一个新的对象相关联.**通常** 用new操作符来实现这一目的的. new关键字的意思是"给我一个新对象,或者说是创建一个新对象".当然除了向极个别的例如String s="wasd",可以用带引号的文本初始化.

  > 但是,上面的例子可以转化为

    ```Java  
      String s = new String("wasd");
    ```
  >  它不仅表示"给我一个新的字符串",而且通过提供一个初始化字符串,给出了怎样产生String的信息

  - 对象在 **程序运行** 的时候,是存储在什么地方呢?
    1. 寄存器.这是最快的存储区,因为它位于不同于其他存储区的地方--处理器内部.但是寄存器的数量机器有限.所以寄存器根据需求进行分配.你不能直接控制,也不能在程序中感受到寄存器存在的任何迹象(另一方便,C和C++允许你向编译器建议寄存器的分配方式)
    2. 堆栈.位于通用RAM(随机访问存储器中),但通过堆栈指针可以从处理器那里获得直接支持.堆栈指针若想下移动,则分配新的内存,若向上移动,则释放那些内存.这是一种告诉有效的分配存储方式,因此与寄存器.创建程序时,Java系统必须知道存储在堆栈内所有项的确切生命周期,以便上下移动堆栈指针.这一约束限制了程序的灵活性,所以虽然某些Java数据存储于堆栈中--特别是 **对象引用**,但是Java对象并不存储于其中.
    3. 堆.一种通用的内存池(位于RAM区),用于存放 **所有的Java对象** .堆不同于堆栈的好处是:编译器不需要知道存储的数据在堆里存活多久的时间.因此,在堆里分配存储有很大的灵活性.当需要一个对象时,只需用new谢一行简单的代码.当执行这行代码时,会自动在堆里面进行存储分配.当然,为这种灵活性必须付出相应的代码:用堆今次那个存储分配和清理可能比堆栈进行存储分配需要更多的时间.
    4. 常量存储.常量值通常直接存放在程序代码内部,这样做是安全的,因为他们永远不会被改变.有时候,在嵌入式系统中,常量本身会和其他部分隔离开来,所以在这种情况下,可以选择将其存放在ROM(只读存储器中).
    5. 非RAM存储.如果数据完全存活于程序之外,那么它可以不受程序的任何空值,在程序没有运行时也可能存在.其中两个基本的例子是流对象和持久化对象.在流对象中,对象转化成字节流,通常被发送给另一台机器.在"持久化对象"中,对象被存放于此番上,因此,即使程序终止,他们可以保持自己的状态.其实,就是说,把对象转化为可以存放在其他 **媒介** 上的事务,需要时,恢复成常规的,基于RAM的对象.举个比较简单的例子理解的话,就是,你从数据库拿数据,然后把输出放入对象中(pojo),就这么简单.

    - 特例: 基本类型
    > 对与基本类型,创建一个并非是引用的"自动"变量.这个变量直接存储"值",并置于堆栈中,因此更加搞笑

      基本类型 | 大小 | 最小值 | 最大值 | 包装器类型
      ------- | ---- | ----- | ------ | --------
      boolean | -    | -   |  - | boolean
      char | 16-bit | Unicode o | Unicode 2^16-1 | Character
      byte | 8 bits | -128 | +127 | Byte
      short | 16 bits | -2^15 | +2^15-1 | short
      int | 32 bits | -2^31 | 2^31-1 | short
      long | 64 bits | -2^63 | +2^63-1 | Integer
      float | 32 bits | IEEE754 | IEEE754 | Float
      double | 64 bits | IEEE754 |IEEE754 | double
      void | - | - | - | Void

      **所有数值类型的都有正负号,所以不要去寻找无符号的数值类型**

      **如果要把基本类向放在堆中的话,那么就是用它的包装类**
      ****
    - 基本不需要销毁对象
      > 这里为什么不说永远呢?说永远的话还需要内存优化吗

       - 作用域
        > 大多数过程型语言都有作用域(scope)的概念.作用域决定了在其内定义的变量名的 **可见性和生命周期** ,在Java中,作用域由花括号的位置决定.

        ```Java
        {
          int x =12;
          //只有 x可用
          {
            int q = 96;
            // x 和q 都可以使用
          }
          // x可以使用,q就超出作用范围了
        }
        ```
      - 对象的作用域
        > Java对象不具备和基本类型一样的生命周期.当用new常见一个Java对象时,它可以存货与作用域之外.

        ```Java
        {
          String s = new String("wasd");
          //作用域结束
        }
        ```
        > **引用s的作用域终点就消失了** ,然而s指向的String对象任然继续占据内存空间.在这段代码中,我们无法在这个作用域之后访问这个对象.因为对它唯一的引用已经超出了作用域的范围.

        > 事实证明,由new创建的对象,只要你需要,就会一直保留下去.但是,如果Java继续让对象存在,那么靠什么才能防止这些对象填满内存空间呢,进而阻塞你的程序呢?Java有一个 **垃圾回收器** ,用来监视用 **new创建的所有对象** ,并辨别那些不会在被引用的对象,虽有,释放这些对象的内存空间,以便拱其他新的对象使用
